<!DOCTYPE html>
<html lang="en">

<body>

    <script src="libs/three.min.js"></script>

    <script type="module">

        import { ObjectControls } from './ObjectControls.js';
        

        const container = document.getElementById('container');
        const raycaster = new THREE.Raycaster();
            const mouse = new THREE.Vector2();

        var renderer = new THREE.WebGLRenderer();
        var controls;
        var camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1000);
        var scene = new THREE.Scene();

        var spinModelMaterial = new THREE.MeshPhongMaterial({ color: 0x49ef4, transparent: true, opacity:.5});
        var spinModelGeometry = new THREE.SphereGeometry(80, 80, 80,0,Math.PI*2,1,1);

        var sampleHotspotGeometry = new THREE.SphereGeometry(2, 100, 100);
        var sampleHotspotMaterial = new THREE.MeshToonMaterial({ color: 0x49ef4, transparent: true });

        var spinModel = new THREE.Mesh(spinModelGeometry, spinModelMaterial);
        var hotspot = new THREE.Mesh(sampleHotspotGeometry, sampleHotspotMaterial);

        var ambient = new THREE.AmbientLight(0xffffff);

        var textures = []

        var textureLoader = new THREE.TextureLoader();
        var texture1 = textureLoader.load('1.png', function (texture) {
            textures.unshift(texture);
            init()
                    for (let index = 2; index < 33; index++) {
                textures.push(textureLoader.load(`${index}.png`))

            }
        });




        function init() {

            camera.position.set(0, 20, -1);

            spinModel.position.set(0, 0, 140)
            camera.lookAt(spinModel.position)

            scene.add(camera);
            scene.add(spinModel)
            spinModel.add(hotspot);
            hotspot.position.set(0,0,80);
            scene.add(ambient);

            document.body.appendChild(renderer.domElement);
            renderer.setSize(window.innerWidth, window.innerHeight);

            /** instantiate ObjectControls**/
            // controls = new ObjectControls(camera, renderer.domElement, spinImage);
            controls = new ObjectControls(camera, renderer.domElement, spinModel, scene, textures);

            fitObjectToScreen(spinModel,camera)
            window.addEventListener('resize', onResize, false);
        }

        const fitObjectToScreen = function (object, camera) {

                var img_w = 1644//object.desiredWidth; 
                var img_h = 1424//object.desiredHeight; 
                var image_ratio = 1

                camera.lookAt(object.position);

                const fitHeightDistance = 2 * Math.tan(Math.PI * (camera.fov) / 360);
                const fitWidthDistance = fitHeightDistance / camera.aspect * image_ratio;

                const defaultFov = camera.fov//this.defaultFov || 60; 

                var _scale = 1;
                if (fitHeightDistance > fitWidthDistance) {
                    _scale = fitHeightDistance;
                } else {
                    _scale = fitHeightDistance * camera.aspect / image_ratio;
                }

                // _scale *= defaultFov / camera.fov; 
                console.log('scale', _scale)

                object.scale.set(_scale, _scale, _scale);

                object.children.forEach(c => {
                    c.scale.set(c.scale.x * _scale, c.scale.y * _scale, c.scale.z * _scale);
                    c.needsUpdate = true; c.updateMatrix();
                });


            }

        function checkPinVisibility() {
            let hotspotPosition = spinModel.children[0].getWorldPosition();
            let parentPosition = spinModel.getWorldPosition();
            if (hotspotPosition.z <= parentPosition.z || Math.abs(hotspotPosition.z) - Math.abs(parentPosition.z) == 0) {
                spinModel.children[0].material.opacity = 1;

            }
            else
                spinModel.children[0].material.opacity = 0;
        }

        function onResize() {

            renderer.setSize(window.innerWidth, window.innerHeight);
            camera.aspect = (window.innerWidth / window.innerHeight);
            camera.updateProjectionMatrix();

        }

        function animate() {
            requestAnimationFrame(animate);
            render();
        }
        function onMouseMove(event) {

                // calculate mouse position in normalized device coordinates
                // (-1 to +1) for both components

                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            }

            window.addEventListener('mousemove', onMouseMove, false);

        function render() {
            checkPinVisibility()
            // raycaster.setFromCamera(mouse, camera);

            // // calculate objects intersecting the picking ray
            // const intersects = raycaster.intersectObjects(scene.children);

            // for (let i = 0; i < intersects.length; i++) {
            //     console.log(intersects[i].point)
            //     intersects[i].object.material.color.set(0x000);

            // }


            renderer.render(scene, camera);
        }



        
        animate();

    </script>
</body>

</html>